import{c as p,d as v,q as o,w as i,g as n,b as c,e as m,u as y,f,h as w,i as d}from"./firebase-0zHLKc2i.js";class g{constructor(t){this.env=t}get(t){return this.env[t]}}let R={mainGroups:["Tarefas","Importante","Meu Dia"],routers:{home:"/",list:"list.html",detail:"detail.html",login:"login.html",register:"register.html"}};class S{constructor(t=[],e=[],s=[]){this.validatorsEdit=t,this.validatorsRemove=e,this.validatorsSave=s}validate(t,e){if(!Array.isArray(e))throw new Error("Estratégia de validação inválida.");e.forEach(s=>s.validate(t))}save(t){return this.validate(t,this.validatorsSave),t}remove(t){return this.validate(t,this.validatorsRemove),t}edit(t,e={}){return this.validate(t,this.validatorsEdit),{...t,...e}}}class T extends S{constructor(t=[],e=[],s=[]){super(t,e,s)}edit(t,e={}){return this.validate(t,this.validatorsEdit),{...t,...e}}}class D{constructor(t,e){this.service=t,this.repository=e}async load(){return await this.repository.load()}async save(t){return this.service.save(t),await this.repository.save(t)}async remove(t){const e=this.service.remove(t);return await this.repository.remove(e)}async edit(t){return await this.repository.edit(t)}async find(t){return await this.repository.find(t)}async clear(t){return await this.repository.clear(t)}}class l extends D{constructor(t,e){super(t,e)}async completed(t){return t.completed?t.completed=!1:t.completed=!0,await this.repository.edit(t)}async load(t){return await this.repository.load(t)}}class E{getQueryParams(t){return new URLSearchParams(window.location.search).get(t)}}class u{constructor(t,e){this.db=t,this.collectionName=e,this.userCached=JSON.parse(localStorage.getItem("userCached"))}colRef(){return p(this.db,this.collectionName)}docRef(t){return v(this.db,this.collectionName,String(t))}async load(){const t=o(this.colRef(),i("user_id","==",this.userCached.uid));return(await n(t)).docs.map(s=>({id:s.id,...s.data()}))}async loadTasks(t){const e=o(this.colRef(),i("group_id","==",t));return(await n(e)).docs.map(r=>({id:r.id,...r.data()}))}async save(t){try{const e=t;if(e.id){const s=this.docRef(e.id);return await c(s,e,{merge:!1}),{id:e.id,...e}}else{const s=await m(this.colRef(),e),r={id:s.id,...e};return await c(s,r,{merge:!0}),r}}catch(e){console.log(e)}}async edit(t){if(!t.id)throw new Error("edit: missing id");const e=t,s=this.docRef(e.id);return await y(s,e),{id:e.id,...e}}async remove(t){const e=typeof t=="object"?t.id:t;if(!e)throw new Error("remove: missing id");const s=this.docRef(e);return await f(s),e}async find(t){const e=this.docRef(t),s=await w(e);return s.exists()?{id:s.id,...s.data()}:null}}class k extends u{constructor(t,e){super(t,e)}async load(t){const e=o(this.colRef(),i("group_id","==",t));return(await n(e)).docs.map(r=>({id:r.id,...r.data()}))}}const h=new T([],[],[]),x=new E,C=new g(R);function N(a){return new l(h,new u(d,a))}function P(a){return new l(h,new k(d,a))}export{P as a,C as c,N as p,x as q,h as s};
