import{d as p,e as m,q as r,w as i,g as n,f as c,h as v,u as f,i as y,j as w,k as d}from"./firebase-CuFNUL_q.js";class g{constructor(t){this.env=t}get(t){return this.env[t]}}let R={mainGroups:["Tarefas","Importante","Meu Dia"],routers:{home:"index.html",list:"list.html",detail:"detail.html",account:"account.html",configurations:"configurations.html",login:"login.html",register:"register.html"}};class S{constructor(t=[],s=[],e=[]){this.validatorsEdit=t,this.validatorsRemove=s,this.validatorsSave=e}validate(t,s){if(!Array.isArray(s))throw new Error("Estratégia de validação inválida.");s.forEach(e=>e.validate(t))}save(t){return this.validate(t,this.validatorsSave),t}remove(t){return this.validate(t,this.validatorsRemove),t}edit(t,s={}){return this.validate(t,this.validatorsEdit),{...t,...s}}}class T extends S{constructor(t=[],s=[],e=[]){super(t,s,e)}edit(t,s={}){return this.validate(t,this.validatorsEdit),{...t,...s}}}class D{constructor(t,s){this.service=t,this.repository=s}async load(){return await this.repository.load()}async save(t){return this.service.save(t),await this.repository.save(t)}async remove(t){const s=this.service.remove(t);return await this.repository.remove(s)}async edit(t){return await this.repository.edit(t)}async find(t){return await this.repository.find(t)}async clear(t){return await this.repository.clear(t)}}class l extends D{constructor(t,s){super(t,s)}async completed(t){return t.completed?t.completed=!1:t.completed=!0,await this.repository.edit(t)}async load(t){return await this.repository.load(t)}}class k{getQueryParams(t){return new URLSearchParams(window.location.search).get(t)}}class u{constructor(t,s){this.db=t,this.collectionName=s,this.userCached=JSON.parse(localStorage.getItem("userCached"))}colRef(){return p(this.db,this.collectionName)}docRef(t){return m(this.db,this.collectionName,String(t))}async load(){const t=r(this.colRef(),i("user_id","==",this.userCached.uid));return(await n(t)).docs.map(e=>({id:e.id,...e.data()}))}async loadTasks(t){const s=r(this.colRef(),i("group_id","==",t));return(await n(s)).docs.map(o=>({id:o.id,...o.data()}))}async save(t){try{const s=t;if(s.id){const e=this.docRef(s.id);return await c(e,s,{merge:!1}),{id:s.id,...s}}else{const e=await v(this.colRef(),s),o={id:e.id,...s};return await c(e,o,{merge:!0}),o}}catch(s){console.log(s)}}async edit(t){if(!t.id)throw new Error("edit: missing id");const s=t,e=this.docRef(s.id);return await f(e,s),{id:s.id,...s}}async remove(t){const s=typeof t=="object"?t.id:t;if(!s)throw new Error("remove: missing id");const e=this.docRef(s);return await y(e),s}async find(t){const s=this.docRef(t),e=await w(s);return e.exists()?{id:e.id,...e.data()}:null}}class E extends u{constructor(t,s){super(t,s)}async load(t){const s=r(this.colRef(),i("group_id","==",t));return(await n(s)).docs.map(o=>({id:o.id,...o.data()}))}}const h=new T([],[],[]),x=new k,C=new g(R);function N(a){return new l(h,new u(d,a))}function P(a){return new l(h,new E(d,a))}export{P as a,C as c,N as p,x as q,h as s};
